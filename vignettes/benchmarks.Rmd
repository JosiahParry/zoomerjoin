---
title: "Benchmarks"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{benchmarks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction

In this short vignette, I show off benchmarks of the zoomerjoin package,
comparing it to the excellent [fuzzyjoin](https://github.com/dgrtwo/fuzzyjoin)
package. The two packages are designed to do different things - the fuzzyjoin
package is *very fast,* and provides more distance functions (as well as other
joining modes) - but it's a useful comparison as it shows off the time that can
be saved using LSH relative to all pairwise comparisons, as long as you are
okay with using Jaccard similarity.

In the future, I am hoping to expand the package to implement [this LSH method
for the edit
distance](https://academic.oup.com/bioinformatics/article/35/14/i127/5529166),
and will add it to the benchmarks when / if this feature is completed.

```{r setup, include=F}
library(tidyverse)
```

## Benchmarks

Here, I show the time it takes fuzzyjoin and zoomerjoin to fuzzily join two
datasets as the size of each dataset increases. Fuzzyjoin is initially quick,
but the runtime scales with the square of the input size. Zoomerjoin is slower
for small datasets but is less memory-intensive, and scales with the sum of
the rows in each dataset, so it becomes quicker for larger datasets.

```{r, echo=F}
sim_data <- read_csv("sim_data.csv")
sim_data  %>%
    mutate(
           name = ifelse(name == "time", "Time Usage (s)", "Memory Usage (MB)"),
           join_type = ifelse(join_type == "Jaccard Distance",
                              "Jaccard Distance Join",
                              "Euclidean Distance Joins"),
           ) %>%
    ggplot(aes(x=as.numeric(n), y=value, col = package, linetype = package)) +
    geom_point() +
    geom_line() +
    facet_wrap(~ join_type + name, scales = 'free') +
    scale_y_continuous("Time (s) / memory (MB)")
```
