---
output: github_document
always_allow_html: true
---

```{r, include=F}
library(tidyverse)
library(microbenchmark)
library(fuzzyjoin)
rextendr::document()
devtools::load_all()

n <- 500000
corpus_1 <- read_csv("bonica.csv")  %>%
    head(n)
names(corpus_1) <- c("a", "field")
corpus_2 <- read_csv("bonica.csv")  %>%
    tail(n)
names(corpus_2) <- c("b", "field")
```


# ZoomerJoin <img src='logo.png' align="right" height="250">

INSANELY, BLAZINGLY FAST fuzzy joins in R. Implimented using
[MinHash](https://en.wikipedia.org/wiki/MinHash), such that each record does
not have to be compared to all other records when matching. This results in
matches that return orders of magnitude faster than other matching packages.

# Installation

## Installing Rust:

You must have [Rust](https://www.rust-lang.org/tools/install) installed
to compile this package. The rust website provides an excellent
installation script that has never caused me any issues.

On Linux, you can install Rust with:

``` sh
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

On Windows, I use the rust installation wizard, found
[here](https://forge.rust-lang.org/infra/other-installation-methods.html).

## Installing Package from Github:

Once you install rust, you should be able to install the package with:

``` r
devtools::install_github("beniaminogreen/zoomerjoin")
```

# Usage:

The package provides the following functions, which are designed to be near to
drop-ins for the corresponding dplyr/fuzzyjoin commands:

* `lsh_left_join()`
* `lsh_right_join()`
* `lsh_inner_join()`
* `lsh_full_join()`
* `lsh_anti_join()`

Here's a snippet showing off how to use the `lhs_left_join()` command:

```{r}
corpus_1
corpus_2

start_time <- Sys.time()
join_out <- lsh_inner_join(corpus_1, corpus_2, n_gram_width=6, n_bands=20, band_width=5)
print(Sys.time() - start_time)
print(join_out)
```

## Benchmarks:

Here's a quick and dirty benchmark showing the performance of this package realative to the default standard, `fuzzyjoin`:

```{r, echo=F, message=F}
test_lsh <- function(n) {
    mean(microbenchmark(
           test <- lsh_inner_join(corpus_1 %>% head(n), corpus_2 %>% tail(n),
           n_gram_width=2, n_bands=50, band_width=5, threshold = .8),
    times = 3)$time)
}

test_string_dist <- function(n) {
    mean(microbenchmark(
           test <- stringdist_inner_join(corpus_1 %>% head(n), corpus_2 %>% tail(n)),
    times = 3)$time)
}


capture.output(time_out <- expand_grid(
            n = c(10,50,100,250,500,1000,2000,3000,4000,5000,6000,7500,10000),
            nesting(
                fun = c(test_lsh, test_string_dist),
                Package = c("zoomerjoin", "fuzzyjoin")
                    )
            )  %>%
mutate(time = map2_dbl(fun, n, ~.x(.y))) %>%
mutate(time = time / 10^9)
, file = "NUL")

time_out %>%
    ggplot(aes(x=n, y=time, col=Package)) +
    geom_line() +
    geom_point() +
    ylab("Time to Process Joins \n (s)") +
    xlab("Number of Entries in Each Dataframe") +
    theme_bw() +
    ggtitle("ZoomerJoin Vs Fuzzyjoin: Speed Comparison")


```




## Limiting the Number of Threads:

To constrain the number of cores the program uses, you can set the
`RAYON_NUM_THREADS` variable before running the search. At present, this
variable is read at the construction of the multithreading thread pool,
and so must be set once each R session. In a future version, I’ll work
to include a fix so that the number of threads can be included in an
argument to the `lhs_join` functions.

Here’s an example of how to set the function to run on an single core in
R:

``` r
Sys.setenv(RAYON_NUM_THREADS=1)
```
